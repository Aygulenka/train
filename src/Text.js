import React from 'react';
import './App.css';
import Example from './Example';

const Text = () =>{
const prim = `
jsx
Copy code
import React, { useEffect, useState } from 'react';

function ExampleComponent() {
  const [data, setData] = useState(null);

  useEffect(() => {
    // Код, который должен выполниться после каждого рендера компонента
    // Например, запрос к API
    fetchData();

    // Функция очистки, которая выполняется перед следующим рендером или при удалении компонента
    return () => {
      // Очистка ресурсов, например, отписка от событий
      cleanup();
    };
  }, [/* зависимости */]);

  return (
    <div>
      {/* Компонент JSX */}
      {data && <p>{data}</p>}
    </div>
  );
}`
    return(
        <div>
            <div>
                <h1>
                Изменение пропсов внутри компонента может привести к ряду потенциальных проблем, включая:
                </h1>
               <p className="bold"> Несогласованность данных:</p> Когда компонент изменяет свои пропсы, это может привести к несогласованности данных между родительским и дочерним компонентами. Родитель может думать, что данные в дочернем компоненте определены определенным образом, в то время как дочерний компонент может обновить пропсы так, что они больше не соответствуют ожиданиям родителя.

               <p className="bold">Непредсказуемость поведения:</p> Изменение пропсов внутри компонента может сделать его поведение менее предсказуемым. Когда компонент получает пропсы извне, его поведение зависит только от входных данных, что делает его более прозрачным и легким в поддержке.

               <p className="bold">Потеря данных:</p> Если компонент изменяет пропсы и не управляет этим процессом должным образом, это может привести к потере данных или перезаписи важных значений, переданных извне.

               <p className="bold">Затруднение отслеживания изменений:</p> Изменение пропсов внутри компонента может усложнить отслеживание того, откуда приходят изменения и как они влияют на состояние компонента.

В целом, хорошей практикой является создание компонентов, которые принимают пропсы извне и не изменяют их внутри. Если изменение пропсов необходимо, рассмотрите возможность использования локального состояния (useState) вместо изменения пропсов.
            </div>
            <div>
                <h1>Что такое state? Для чего он используется?</h1>
                <p>
                State (состояние) в React представляет собой объект, который содержит данные, влияющие на отображение компонента. Это внутренний объект компонента, который может изменяться в течение жизненного цикла компонента.
</p>
                <p >State используется для хранения и управления динамическими данными, которые могут изменяться в результате взаимодействия пользователя, сетевых запросов, или других внешних событий. Он позволяет компонентам React отслеживать изменения данных и перерисовывать себя при необходимости, чтобы отобразить актуальную информацию.
                </p>
                <p className="bold">Основные характеристики state:</p>

                <p className="bold">Локальность:</p> Каждый компонент в React может иметь свой собственный state, который не влияет на состояние других компонентов. Это позволяет создавать изолированные и переиспользуемые компоненты.

                <p className="bold">Изменяемость:</p> State можно изменять с использованием функции setState. После изменения state, React перерисовывает компонент, чтобы отобразить новые данные.
                
                <p className="bold">Пример</p>
                <Example />
                <p className='bold'>Что происходит, когда вы вызываете setState?</p>


<p>setState используется для обновления состояния компонента в React. При вызове setState, React обновляет состояние компонента и перерисовывает его. Это также запускает процесс сравнения виртуального DOM с реальным DOM, что приводит к обновлению интерфейса.
</p><p className='bold'>Рассказать про каждый метод LifeCycle
</p><p>
<span className='bold'>componentDidMount: </span>Вызывается после того, как компонент был добавлен в DOM. Это место для выполнения действий, которые требуют наличие DOM-узлов, например, инициализация внешних библиотек или запросы к серверу.
<span className='bold'>componentDidUpdate:</span> Вызывается после того, как обновления компонента были применены к DOM. Полезен для выполнения действий после каждого обновления, например, для обработки изменений в DOM или выполнения запросов к серверу.
<span className='bold'>componentWillUnmount: </span>Вызывается перед тем, как компонент будет удален из DOM. Место для очистки ресурсов, отписки от событий и т.д.
</p><p className='bold'>
Что нельзя делать в методе render()?
</p>
В методе render() нельзя изменять состояние компонента напрямую с помощью setState. Это может привести к бесконечному циклу перерисовки.
<p className='bold'>Каким образом передаются данные от родительской компоненты к дочерним?
</p>
Данные передаются от родительской компоненты к дочерней через свойства (props). Родительская компонента передает значения через атрибуты JSX, которые затем становятся доступными в дочерней компоненте как props.
<p className='bold'>Какие бывают события (Events) в React?
</p>
В React используются события, аналогичные традиционным событиям DOM, таким как onClick, onChange, onSubmit и т.д. Эти события используются для обработки действий пользователя. В React также существует синтетическая система событий, которая предоставляет кросс-браузерную абстракцию для обработки событий.
<p className='bold'>
useEffect - это хук в React, предназначенный для выполнения побочных эффектов в функциональных компонентах. Побочные эффекты включают в себя такие вещи, как получение данных, подписка на события, изменения DOM и другие действия, которые необходимо выполнить в процессе жизни компонента, кроме обычного рендеринга.
</p>.
<p className='bold'>
Основные цели useEffect:
</p>
Запуск побочных эффектов: Выполнение кода, который необходим для работы компонента, но не должен блокировать его обычный цикл жизни.
<p>
Обработка подписок и запросов: useEffect часто используется для установки подписок на данные (например, с использованием WebSocket или EventSource), выполнения асинхронных запросов к серверу, получения данных из хранилища и других асинхронных операций.
</p><p>
Очистка ресурсов: useEffect предоставляет возможность очищать ресурсы, такие как подписки и таймеры, чтобы избежать утечек памяти.
</p>
Пример использования useEffect:
<pre>
    <code>
        {prim}
    </code>
</pre>

useEffect принимает два аргумента: функцию, содержащую код побочного эффекта, и массив зависимостей. Зависимости используются для указания, когда следует снова запустить эффект. Если массив зависимостей пуст или не указан, эффект выполняется после каждого рендера.

<p>
В React существует несколько <span className='bold'>основных хуков</span>, которые предоставляют функциональным компонентам доступ к состоянию, эффектам и другим возможностям. Вот семь основных хуков:
<p></p>
useState:
</p><p>
Предоставляет возможность добавить локальное состояние в функциональные компоненты.
</p><p>Принимает начальное значение и возвращает массив, содержащий текущее значение состояния и функцию для его обновления.
</p><p>
const [state, setState] = useState(initialState);
</p><p>
useEffect:
</p><p>
Позволяет выполнять побочные эффекты в функциональных компонентах.
</p><p>
Принимает функцию-эффект и массив зависимостей, указывающих, когда эффект должен быть запущен.
</p><p>
useEffect(() => {
  // Побочные эффекты
}, [dependencies]);
</p><p>
useContext:
</p><p>
Позволяет функциональным компонентам получать значение из контекста.
</p><p>
Принимает объект контекста, возвращенного из React.createContext().
</p><p>
const value = useContext(MyContext);
</p><p>useReducer:
</p><p>
Предоставляет более сложное управление состоянием, используя функцию редуктора.
</p><p>Возвращает текущее состояние и функцию для диспетчера действий.
</p><p>
const [state, dispatch] = useReducer(reducer, initialState);
</p><p>
useCallback:
</p><p>
Возвращает мемоизированную версию обратного вызова, что полезно для предотвращения лишних рендеров.
</p><p>
const memoizedCallback = useCallback(() => {
  // ...
}, [dependencies]);
</p><p>
useMemo:
</p><p>
Позволяет мемоизировать вычисленное значение, чтобы избежать его пересчета при каждом рендере.
</p><p>
const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);
</p><p>
useRef:
</p><p>
Создает объект ref, который может быть использован для доступа к DOM-узлам или сохранения мутабельных значений между рендерами.
</p><p>
const myRef = useRef(initialValue);
</p><p>Эти хуки предоставляют мощные средства для работы с состоянием, эффектами и другими возможностями в функциональных компонентах в React.
</p>
<p className='bold'>React.memo</p>
<p>
React.memo - это функция высшего порядка (HOC), которая помогает избежать повторного рендеринга функционального компонента, если его пропсы не изменились. Это особенно полезно, когда компонент рендерится снова, но его пропсы остаются неизменными.
</p>
<p className='bold'>Зачем использовать?</p>
<span className="bold">Оптимизация производительности</span>помогает избежать ненужного рендеринга и пересоздания данных, улучшая производительность вашего приложения.
<p>
<span className='bold'>Предотвращение лишних ререндеров:</span>React.memo гарантирует, что компонент будет рендериться только при изменении его пропсов, что особенно полезно в случае с большими деревьями компонентов.
</p>
<p className='bold'>useMemo</p>
<p>Хук useMemo используется для мемоизации значений и предотвращения их пересоздания при каждом рендеринге компонента. Он полезен, когда вы хотите оптимизировать вычислительные операции или избежать повторного создания объектов.</p>
<p className='bold'>Зачем использовать?</p>
<p>
<span className="bold">Оптимизация производительности</span>помогает избежать ненужного рендеринга и пересоздания данных, улучшая производительность вашего приложения.
</p>
<span className="bold">Избегание избыточных вычислений: useMemo</span>позволяет кэшировать результаты дорогостоящих вычислений, предотвращая их пересчет при каждом рендеринге.

            </div>

        </div>
    )
}

export default Text